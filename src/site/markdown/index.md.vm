Farser
========

*Formula lexer/tokenizer and abstract syntaxt tree (AST) with focus on logical formulas*

------

*Farser* is a very simplistic library which contains

**A lexer/tokenizer:**

Splits a formula or domain code string into tokens. It can be extended with any kind of custom tokens.

The purpose of a lexer is simply to separate the input into tokens. No validation of the input is performed (this would be the task of a parser).


**An Abstract Syntax Tree (AST) implementation:** 

Evaluation of a formula based on a list of lexer tokens.



---------------------

#Lexer

At the time of this writing, the lexer recognized the following token/formula types:
  
#[[##]]#3M domain code

All tokens are defined in `DomainCodeToken`.
  
  * **"("** - Left parenthesis
  * **")"** - Right parenthesis
  * **"&"** - Logical and
  * **"|"** - Logical or
  * **"~"** - Logical not
  * **","** - Comma
  * **"="** - Equal
  * **">"** - Greater than
  * **"<"** - Less than
  * **">="** - Greater than/equal 
  * **"<="** - Less than/equal
  * **":="** - Assign a value to a variable
  * **"->"** - A pointer
  * **ATOM** - Anything that is not a token symbol from above
  
Lex with `DomainCodeLexer.lex`.
  
  
  
#[[##]]#DRG formulas

All tokens are defined in `DrgFormulaToken`.

  * **"("** - Left parenthesis
  * **")"** - Right parenthesis
  * **"&"** - Logical and
  * **"|"** - Logical or
  * **"~"** - Logical not
  * **ATOM** - Anything that is not a token symbol from above

Lex with `DrgFormulaLexer.lex`.
  
In addition to splitting a DRG formula into tokens, `DrgLexerToken` also supports a prefix for any ATOM tokens. 
If it finds a string separated by colon ":" (see `DrgLexerToken#PREFIX_SEPARATOR_CHAR`) it splits this into a value and a 
prefix (e.g. "PFX:val" is split into prefix "PFX" and value "val"). This is implemented in the `DrgFormulaTokenFactory`.


#[[##]]#Custom tokens
  
A custom set of tokens can be created by implementing
  
  * an enum with `TokenType`
    * This is the list of all character sequences which should be recognized as token, including a `CommonTokenType.ATOM` which is used when a character sequence does not match any token.
    * ensure any mandatory `CommonTokenType` are implemented
  * a class with `LexerTokenFactory`
    * This factory creates the `LexerToken` based on `TokenType` and the value
  * and a class with `LexerToken`
    * This is the container which gets produced as a result of the lexing. It contains the `TokenType` and the value of the token

See `*.farser.lexer.domain` and `*.farser.lexer.drg` as example of the above implementations.



#Example


**DRG Formula:**

`"A | (~PFX:someValue & ~otherValue) & aFunction(param1, param2)"`

Processing this as DRG formula 

```java
    List<DrgLexerToken> lexed = DrgFormulaLexer.lex("... your formula ...");

```

will result in a list of `DrgLexerToken` with the following:

  1. `DrgFormulaToken.ATOM`, value = "A"
  2. `DrgFormulaToken.OR`, value = "|"
  3. `DrgFormulaToken.LPAREN`, value = "("
  4. `DrgFormulaToken.NOT`, value = "~"
  5. `DrgFormulaToken.ATOM`, value = "someValue", prefix = "PFX"
  6. `DrgFormulaToken.AND`, value = "&"
  7. `DrgFormulaToken.NOT`, value = "~"
  8. `DrgFormulaToken.ATOM`, value = "otherValue"
  9. `DrgFormulaToken.RPAREN`, value = ")"
  10. `DrgFormulaToken.AND`, value = "&"
  11. `DrgFormulaToken.ATOM`, value = "aFunction"
  12. `DrgFormulaToken.LPAREN`, value = "("
  13. `DrgFormulaToken.ATOM`, value = "param1"
  14. `DrgFormulaToken.COMMA`, value = ","
  15. `DrgFormulaToken.ATOM`, value = "param2"
  16. `DrgFormulaToken.RPAREN`, value = ")"





------------------------


#Abstract Syntax Tree (AST)

The abstract syntax tree represents a formula (or theoretically any source code) in a tree structure. Traversing the tree 
allows the evaluation of the formula in addition to implement any kind of logic needed for each tree node it visits during 
evaluation.

This AST implementation currently contains the evaluation for logical (boolean) DRG formulas. It is implemented as 
`DescentParser` to create the `DrgSyntaxTree` (the actual AST).

The AST can be built with 

```java
//A formula, tokenized with the lexer documented above
List<DrgLexerToken> lexerTokens = DrgFormulaLexer.lex("(BILATERAL) & (D|E)");

//A parser.
//With a default supplier to create the AST nodes when no specific value supplier is available.
//And a map of specific suppliers which get used when their defined token value is encountered.
DescentParser<String> parser = new DescentParser<>(lexerTokens.listIterator(),
        defaultSupplier, suppliers);

//Build the tree
DrgSyntaxTree<String> ast = parser.buildExpressionTree();

//Evaluate the tree
List<String> mask = Arrays.asList("E");
ExpressionResult<String> evaluation = ast.evaluateExpression(mask);

//The logical result of the formula evaluation
evaluation.isMatched();
//Set of terminal objects that were matched during the expression evaluation
evaluation.getMatches();

```



-------------------

#Usage


```
<dependency>
	<groupId>${project.groupId}</groupId>
	<artifactId>${project.artifactId}</artifactId>
	<version>${project.version}</version>
</dependency>
```



